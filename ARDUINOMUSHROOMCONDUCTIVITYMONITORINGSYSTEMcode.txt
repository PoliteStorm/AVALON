
#### 4.4.2 Advanced Code with LCD and Data Logging
See the full code in section 4.4.3 of the original document.

### 4.5 Calibration Procedure

#### 4.5.1 Standard Solutions
Prepare calibration solutions using potassium chloride (KCl):

1. Low conductivity (1.413 mS/cm):
   - Dissolve 0.746 grams KCl in 1 liter distilled water

2. Medium conductivity (12.88 mS/cm):
   - Dissolve 7.456 grams KCl in 1 liter distilled water

3. High conductivity (111.8 mS/cm):
   - Dissolve 74.56 grams KCl in 1 liter distilled water

#### 4.5.2 Calibration Steps
1. Prepare standard solutions and verify with commercial conductivity meter if available
2. Immerse electrodes in each solution, ensuring they are at the same depth each time
3. Record the raw analog readings for each solution
4. Calculate calibration factor:
   - calibrationFactor = known_conductivity / (voltage_reading)
5. Update the calibrationFactor in your Arduino code
6. Verify by measuring the standard solutions again

#### 4.5.3 Substrate-Specific Calibration
For more accurate readings in actual substrate:

1. Prepare a sample of your substrate with known moisture content
2. Measure with commercial conductivity meter if available
3. Compare with Arduino readings and adjust calibrationFactor
4. Create a calibration curve for different moisture levels

## 5. DATA COLLECTION AND ANALYSIS

### 5.1 Measurement Protocol

#### 5.1.1 Electrode Placement
1. Insert electrodes to consistent depth (1/3 of substrate height recommended)
2. Maintain fixed distance between measurements
3. Mark positions for repeatability
4. Consider multiple measurement points for larger substrates

#### 5.1.2 Measurement Frequency
- Baseline: After substrate preparation and spiking
- Colonization phase: Daily measurements
- Fruiting phase: Every 6-12 hours
- Post-harvest: Before and after each flush

#### 5.1.3 Environmental Factors
Record alongside conductivity:
- Temperature
- Relative humidity
- CO2 levels (if available)
- Light exposure
- Time since inoculation

### 5.2 Data Interpretation

#### 5.2.1 Typical Conductivity Patterns
- Initial phase: Slight decrease as mycelium begins consuming minerals
- Mid colonization: Gradual increase as mycelial network develops
- Full colonization: Plateau or continued slow increase
- Primordia formation: Often shows slight dip
- Fruiting: Fluctuations as nutrients move to fruiting bodies

#### 5.2.2 Indicators of Problems
- Sudden drop: Possible contamination or moisture loss
- Failure to increase: Poor mycelial growth or mineral availability
- Erratic readings: Possible sensor issues or contamination

#### 5.2.3 Optimum Conductivity Ranges
Varies by species, but general guidelines:
- Pleurotus spp.: 0.05-0.15 S/m
- Ganoderma spp.: 0.03-0.10 S/m
- Trametes spp.: 0.02-0.08 S/m

### 5.3 Optimization Strategies

#### 5.3.1 Adjusting Mineral Content
- If conductivity too low: Increase calcined material percentage
- If conductivity too high: Reduce mineral supplements

#### 5.3.2 Moisture Management
- Optimal moisture: 55-65% for most species
- Too dry: Mist with mineral-enriched water
- Too wet: Increase air exchange

#### 5.3.3 pH Adjustment
- Most minerals are more bioavailable at pH 6.0-7.0
- Adjust with citric acid (to lower) or calcium carbonate (to raise)

#### 5.3.4 Experimental Design
For systematic optimization:
1. Create multiple batches with single variable changes
2. Maintain detailed records of all parameters
3. Compare conductivity development curves
4. Identify optimal conditions for your specific application

## 6. REFERENCES AND FURTHER READING

### 6.1 Scientific Literature

1. Adamatzky, A. (2018). "Towards fungal computer." Interface Focus, 8(6), 20180029.
   https://doi.org/10.1098/rsfs.2018.0029

2. Beasley, A. E., Powell, A. L., & Adamatzky, A. (2020). "Fungal photosensors." arXiv preprint arXiv:2003.07825.

3. Haneef, M., Ceseracciu, L., Canale, C., Bayer, I. S., Heredia-Guerrero, J. A., & Athanassiou, A. (2017). "Advanced materials from fungal mycelium: fabrication and tuning of physical properties." Scientific Reports, 7, 41292.
   https://doi.org/10.1038/srep41292

4. Islam, M. R., Tudryn, G., Bucinell, R., Schadler, L., & Picu, R. C. (2017). "Morphology and mechanics of fungal mycelium." Scientific Reports, 7(1), 13070.
   https://doi.org/10.1038/s41598-017-13295-2

5. Stamets, P. (2005). "Mycelium running: how mushrooms can help save the world." Random House Digital, Inc.

### 6.2 Technical Resources

1. Arduino Official Documentation
   https://www.arduino.cc/reference/en/

2. "Conductivity Theory and Practice" - Radiometer Analytical
   https://www.analytics-shop.com/media/Conductivity_Theory_and_Practice.pdf

3. "Electrical Conductivity of Soils and Plants" - USDA Agricultural Research Service
   https://www.ars.usda.gov/ARSUserFiles/20360500/pdf_pubs/P1332.pdf

4. "Mushroom Cultivation" by Peter Oei
   https://www.echobooks.org/products/mushroom-cultivation

5. "The Art and Science of Composting" - University of Wisconsin
   https://www.cias.wisc.edu/wp-content/uploads/2008/07/artofcompost.pdf

### 6.3 Online Communities and Resources

1. Shroomery Forum - Cultivation
   https://www.shroomery.org/forums/postlist.php/Board/2

2. Arduino Forum - Sensors
   https://forum.arduino.cc/index.php?board=6.0

3. Open Source Ecology - Mushroom Production
   https://wiki.opensourceecology.org/wiki/Mushroom_Production

4. Mycology subreddit
   https://www.reddit.com/r/mycology/

5. Fungi Academy
   https://fungi.academy/

---


// ================================================================
// ARDUINO MUSHROOM CONDUCTIVITY MONITORING SYSTEM
// Complete code for measuring electrical conductivity in mushroom substrates
// Includes basic and advanced versions with data logging capabilities
// ================================================================

// ================================================================
// BASIC VERSION - SERIAL OUTPUT ONLY
// ================================================================

// Conductivity Sensor for Mushroom Substrate - Basic Version
// Measures electrical conductivity using two electrodes

// Pin definitions
const int powerPin = 7;      // Digital pin to power one electrode
const int sensePin = A0;     // Analog pin to read voltage
const int measureInterval = 5000;  // Time between measurements (ms)

// Calibration values
const float calibrationFactor = 0.0023;  // Convert to Siemens/meter
const float temperatureCoefficient = 0.019;  // Conductivity change per degree C

// Variables
float conductivity = 0.0;
float temperature = 25.0;    // Ambient temperature in Celsius
unsigned long lastMeasureTime = 0;

void setup() {
  // Initialize serial communication
  Serial.begin(9600);
  Serial.println("Mushroom Substrate Conductivity Sensor");
  Serial.println("--------------------------------------");
  
  // Set up pins
  pinMode(powerPin, OUTPUT);
  digitalWrite(powerPin, LOW);  // Start with power off
  
  // Wait for serial monitor to open
  delay(1000);
}

void loop() {
  // Check if it's time to take a measurement
  if (millis() - lastMeasureTime >= measureInterval) {
    lastMeasureTime = millis();
    
    // Take conductivity measurement
    float rawConductivity = measureConductivity();
    
    // Apply temperature compensation
    conductivity = compensateTemperature(rawConductivity, temperature);
    
    // Print results
    Serial.print("Time (s): ");
    Serial.print(millis() / 1000);
    Serial.print(", Conductivity: ");
    Serial.print(conductivity, 6);
    Serial.println(" S/m");
  }
}

float measureConductivity() {
  // Power the electrode
  digitalWrite(powerPin, HIGH);
  
  // Wait for stable reading
  delay(100);
  
  // Take multiple readings and average
  int numReadings = 10;
  int total = 0;
  
  for (int i = 0; i < numReadings; i++) {
    total += analogRead(sensePin);
    delay(10);
  }
  
  // Turn off power to prevent electrolysis
  digitalWrite(powerPin, LOW);
  
  // Calculate average reading
  float averageReading = total / (float)numReadings;
  
  // Convert to voltage
  float voltage = averageReading * (5.0 / 1023.0);
  
  // Convert to conductivity (Siemens/meter)
  // This conversion depends on your electrode geometry and needs calibration
  float rawConductivity = voltage * calibrationFactor;
  
  return rawConductivity;
}

float compensateTemperature(float rawConductivity, float temp) {
  // Standard temperature compensation formula
  return rawConductivity / (1.0 + temperatureCoefficient * (temp - 25.0));
}

// ================================================================
// ADVANCED VERSION - WITH LCD DISPLAY AND SD CARD LOGGING
// ================================================================

/*
// Conductivity Sensor for Mushroom Substrate - Advanced Version
// Includes LCD display, SD card logging, and RTC for timestamping

#include <LiquidCrystal_I2C.h>
#include <SD.h>
#include <SPI.h>
#include <Wire.h>
#include <RTClib.h>
#include <OneWire.h>
#include <DallasTemperature.h>

// Pin definitions
const int powerPin = 7;      // Digital pin to power one electrode
const int sensePin = A0;     // Analog pin to read voltage
const int sdChipSelect = 10; // SD card chip select pin
const int tempSensorPin = 2; // DS18B20 temperature sensor pin
const int measureInterval = 60000;  // Time between measurements (ms)

// Calibration values
const float calibrationFactor = 0.0023;  // Convert to Siemens/meter
const float temperatureCoefficient = 0.019;  // Conductivity change per degree C

// Objects
LiquidCrystal_I2C lcd(0x27, 16, 2);  // Set I2C address and LCD dimensions
RTC_DS3231 rtc;
OneWire oneWire(tempSensorPin);
DallasTemperature tempSensor(&oneWire);
File dataFile;

// Variables
float conductivity = 0.0;
float temperature = 25.0;
unsigned long lastMeasureTime = 0;
String fileName = "CONDUCT.CSV";

void setup() {
  // Initialize serial communication
  Serial.begin(9600);
  Serial.println("Mushroom Substrate Conductivity Sensor");
  Serial.println("--------------------------------------");
  
  // Set up pins
  pinMode(powerPin, OUTPUT);
  digitalWrite(powerPin, LOW);  // Start with power off
  
  // Initialize temperature sensor
  tempSensor.begin();
  
  // Initialize LCD
  lcd.init();
  lcd.backlight();
  lcd.print("Conductivity");
  lcd.setCursor(0, 1);
  lcd.print("Sensor Starting");
  
  // Initialize RTC
  if (!rtc.begin()) {
    Serial.println("Couldn't find RTC");
    lcd.clear();
    lcd.print("RTC Error");
  }
  
  // Set RTC time if needed (uncomment and set to compile time once)
  // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  
  // Initialize SD card
  if (!SD.begin(sdChipSelect)) {
    Serial.println("SD card initialization failed!");
    lcd.clear();
    lcd.print("SD Card Error");
  } else {
    // Create header in data file if it doesn't exist
    if (!SD.exists(fileName)) {
      dataFile = SD.open(fileName, FILE_WRITE);
      if (dataFile) {
        dataFile.println("Date,Time,Conductivity(S/m),Temperature(C)");
        dataFile.close();
      }
    }
  }
  
  delay(2000);
  lcd.clear();
}

void loop() {
  // Check if it's time to take a measurement
  if (millis() - lastMeasureTime >= measureInterval) {
    lastMeasureTime = millis();
    
    // Get current time
    DateTime now = rtc.now();
    
    // Get temperature from DS18B20 sensor
    tempSensor.requestTemperatures();
    temperature = tempSensor.getTempCByIndex(0);
    
    // If temperature sensor fails, use RTC temperature as backup
    if (temperature == DEVICE_DISCONNECTED_C) {
      temperature = rtc.getTemperature();
    }
    
    // Take conductivity measurement
    float rawConductivity = measureConductivity();
    
    // Apply temperature compensation
    conductivity = compensateTemperature(rawConductivity, temperature);
    
    // Update LCD
    lcd.clear();
    lcd.print("Cond: ");
    lcd.print(conductivity, 6);
    lcd.setCursor(0, 1);
    lcd.print("Temp: ");
    lcd.print(temperature, 1);
    lcd.print("C");
    
    // Log data to SD card
    logData(now, conductivity, temperature);
    
    // Print results to serial
    Serial.print(now.year(), DEC);
    Serial.print('/');
    Serial.print(now.month(), DEC);
    Serial.print('/');
    Serial.print(now.day(), DEC);
    Serial.print(" ");
    Serial.print(now.hour(), DEC);
    Serial.print(':');
    Serial.print(now.minute(), DEC);
    Serial.print(':');
    Serial.print(now.second(), DEC);
    Serial.print(", Conductivity: ");
    Serial.print(conductivity, 6);
    Serial.print(" S/m, Temp: ");
    Serial.print(temperature, 1);
    Serial.println("C");
  }
}

float measureConductivity() {
  // Power the electrode
  digitalWrite(powerPin, HIGH);
  
  // Wait for stable reading
  delay(100);
  
  // Take multiple readings and average
  int numReadings = 10;
  int total = 0;
  
  for (int i = 0; i < numReadings; i++) {
    total += analogRead(sensePin);
    delay(10);
  }
  
  // Turn off power to prevent electrolysis
  digitalWrite(powerPin, LOW);
  
  // Calculate average reading
  float averageReading = total / (float)numReadings;
  
  // Convert to voltage
  float voltage = averageReading * (5.0 / 1023.0);
  
  // Convert to conductivity (Siemens/meter)
  float rawConductivity = voltage * calibrationFactor;
  
  return rawConductivity;
}

float compensateTemperature(float rawConductivity, float temp) {
  // Standard temperature compensation formula
  return rawConductivity / (1.0 + temperatureCoefficient * (temp - 25.0));
}

void logData(DateTime timestamp, float cond, float temp) {
  dataFile = SD.open(fileName, FILE_WRITE);
  
  if (dataFile) {
    // Format: YYYY/MM/DD,HH:MM:SS,conductivity,temperature
    dataFile.print(timestamp.year(), DEC);
    dataFile.print('/');
    dataFile.print(timestamp.month(), DEC);
    dataFile.print('/');
    dataFile.print(timestamp.day(), DEC);
    dataFile.print(",");
    dataFile.print(timestamp.hour(), DEC);
    dataFile.print(':');
    dataFile.print(timestamp.minute(), DEC);
    dataFile.print(':');
    dataFile.print(timestamp.second(), DEC);
    dataFile.print(",");
    dataFile.print(cond, 6);
    dataFile.print(",");
    dataFile.println(temp, 2);
    
    dataFile.close();
  }
}
*/

// ================================================================
// ENHANCED VERSION - WITH MULTIPLE SENSORS AND WIFI CONNECTIVITY
// ================================================================

/*
// Conductivity Sensor for Mushroom Substrate - Enhanced Version
// Includes multiple sensor support, WiFi connectivity, and web dashboard

#include <LiquidCrystal_I2C.h>
#include <SD.h>
#include <SPI.h>
#include <Wire.h>
#include <RTClib.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <WiFiNINA.h>  // For Arduino MKR WiFi 1010, Nano 33 IoT, etc.
// Use <ESP8266WiFi.h> for ESP8266 or <WiFi.h> for ESP32

// WiFi credentials
const char* ssid = "YourWiFiSSID";
const char* password = "YourWiFiPassword";

// Pin definitions
const int powerPin1 = 7;     // Digital pin to power electrode set 1
const int powerPin2 = 6;     // Digital pin to power electrode set 2
const int sensePin1 = A0;    // Analog pin to read voltage from set 1
const int sensePin2 = A1;    // Analog pin to read voltage from set 2
const int sdChipSelect = 10; // SD card chip select pin
const int tempSensorPin = 2; // DS18B20 temperature sensor pin
const int humidityPin = A2;  // Analog humidity sensor pin
const int measureInterval = 60000;  // Time between measurements (ms)

// Calibration values
const float calibrationFactor1 = 0.0023;  // Calibration for sensor 1
const float calibrationFactor2 = 0.0025;  // Calibration for sensor 2
const float temperatureCoefficient = 0.019;  // Conductivity change per degree C

// Objects
LiquidCrystal_I2C lcd(0x27, 20, 4);  // Larger LCD for more data
RTC_DS3231 rtc;
OneWire oneWire(tempSensorPin);
DallasTemperature tempSensor(&oneWire);
File dataFile;
WiFiServer server(80);  // Web server on port 80

// Variables
float conductivity1 = 0.0;
float conductivity2 = 0.0;
float temperature = 25.0;
float humidity = 0.0;
unsigned long lastMeasureTime = 0;
String fileName = "CONDUCT.CSV";
int wifiStatus = WL_IDLE_STATUS;

void setup() {
  // Initialize serial communication
  Serial.begin(9600);
  Serial.println("Enhanced Mushroom Substrate Conductivity Monitoring System");
  Serial.println("--------------------------------------------------------");
  
  // Set up pins
  pinMode(powerPin1, OUTPUT);
  pinMode(powerPin2, OUTPUT);
  digitalWrite(powerPin1, LOW);
  digitalWrite(powerPin2, LOW);
  
  // Initialize temperature sensor
  tempSensor.begin();
  
  // Initialize LCD
  lcd.init();
  lcd.backlight();
  lcd.print("Conductivity");
  lcd.setCursor(0, 1);
  lcd.print("Monitoring System");
  
  // Initialize RTC
  if (!rtc.begin()) {
    Serial.println("Couldn't find RTC");
    lcd.setCursor(0, 2);
    lcd.print("RTC Error");
  }
  
  // Initialize SD card
  if (!SD.begin(sdChipSelect)) {
    Serial.println("SD card initialization failed!");
    lcd.setCursor(0, 3);
    lcd.print("SD Card Error");
  } else {
    // Create header in data file if it doesn't exist
    if (!SD.exists(fileName)) {
      dataFile = SD.open(fileName, FILE_WRITE);
      if (dataFile) {
        dataFile.println("Date,Time,Conductivity1(S/m),Conductivity2(S/m),Temperature(C),Humidity(%)");
        dataFile.close();
      }
    }
  }
  
  // Connect to WiFi
  lcd.clear();
  lcd.print("Connecting to WiFi");
  
  // Attempt to connect to WiFi network
  while (wifiStatus != WL_CONNECTED) {
    Serial.print("Attempting to connect to SSID: ");
    Serial.println(ssid);
    lcd.setCursor(0, 1);
    lcd.print("Connecting...");
    
    // Connect to WPA/WPA2 network
    wifiStatus = WiFi.begin(ssid, password);
    
    // Wait 10 seconds for connection
    delay(10000);
  }
  
  // Start the web server
  server.begin();
  
  // Display connection status
  lcd.clear();
  lcd.print("Connected to WiFi");
  lcd.setCursor(0, 1);
  lcd.print("IP: ");
  lcd.print(WiFi.localIP());
  
  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  
  delay(3000);
  lcd.clear();
}

void loop() {
  // Check for client connections
  WiFiClient client = server.available();
  if (client) {
    handleWebClient(client);
  }
  
  // Check if it's time to take a measurement
  if (millis() - lastMeasureTime >= measureInterval) {
    lastMeasureTime = millis();
    
    // Get current time
    DateTime now = rtc.now();
    
    // Get temperature from DS18B20 sensor
    tempSensor.requestTemperatures();
    temperature = tempSensor.getTempCByIndex(0);
    
    // If temperature sensor fails, use RTC temperature as backup
    if (temperature == DEVICE_DISCONNECTED_C) {
      temperature = rtc.getTemperature();
    }
    
    // Read humidity sensor
    int humidityRaw = analogRead(humidityPin);
    humidity = map(humidityRaw, 0, 1023, 0, 100);  // Map to 0-100%
    
    // Take conductivity measurements
    float rawConductivity1 = measureConductivity(powerPin1, sensePin1, calibrationFactor1);
    float rawConductivity2 = measureConductivity(powerPin2, sensePin2, calibrationFactor2);
    
    // Apply temperature compensation
    conductivity1 = compensateTemperature(rawConductivity1, temperature);
    conductivity2 = compensateTemperature(rawConductivity2, temperature);
    
    // Update LCD
    updateLCD(conductivity1, conductivity2, temperature, humidity);
    
    // Log data to SD card
    logData(now, conductivity1, conductivity2, temperature, humidity);
    
    // Print results to serial
    printData(now, conductivity1, conductivity2, temperature, humidity);
  }
}

float measureConductivity(int powerPin, int sensePin, float calFactor) {
  // Power the electrode
  digitalWrite(powerPin, HIGH);
  
  // Wait for stable reading
  delay(100);
  
  // Take multiple readings and average
  int numReadings = 10;
  int total = 0;
  
  for (int i = 0; i < numReadings; i++) {
    total += analogRead(sensePin);
    delay(10);
  }
  
  // Turn off power to prevent electrolysis
  digitalWrite(powerPin, LOW);
  
  // Calculate average reading
  float averageReading = total / (float)numReadings;
  
  // Convert to voltage
  float voltage = averageReading * (5.0 / 1023.0);
  
  // Convert to conductivity (Siemens/meter)
  float rawConductivity = voltage * calFactor;
  
  return rawConductivity;
}

float compensateTemperature(float rawConductivity, float temp) {
  // Standard temperature compensation formula
  return rawConductivity / (1.0 + temperatureCoefficient * (temp - 25.0));
}

void updateLCD(float cond1, float cond2, float temp, float hum) {
  lcd.clear();
  lcd.print("Cond1: ");
  lcd.print(cond1, 5);
  lcd.print(" S/m");
  
  lcd.setCursor(0, 1);
  lcd.print("Cond2: ");
  lcd.print(cond2, 5);
  lcd.print(" S/m");
  
  lcd.setCursor(0, 2);
  lcd.print("Temp: ");
  lcd.print(temp, 1);
  lcd.print("C");
  
  lcd.setCursor(0, 3);
  lcd.print("Humidity: ");
  lcd.print(hum, 1);
  lcd.print("%");
}

void logData(DateTime timestamp, float cond1, float cond2, float temp, float hum) {
  dataFile = SD.open(fileName, FILE_WRITE);
  
  if (dataFile) {
    // Format: YYYY/MM/DD,HH:MM:SS,conductivity1,conductivity2,temperature,humidity
    dataFile.print(timestamp.year(), DEC);
    dataFile.print('/');
    dataFile.print(timestamp.month(), DEC);
    dataFile.print('/');
    dataFile.print(timestamp.day(), DEC);
    dataFile.print(",");
    dataFile.print(timestamp.hour(), DEC);
    dataFile.print(':');
    dataFile.print(timestamp.minute(), DEC);
    dataFile.print(':');
    dataFile.print(timestamp.second(), DEC);
    dataFile.print(",");
    dataFile.print(cond1, 6);
    dataFile.print(",");
    dataFile.print(cond2, 6);
    dataFile.print(",");
    dataFile.print(temp, 2);
    dataFile.print(",");
    dataFile.println(hum, 2);
    
    dataFile.close();
  }
}

void printData(DateTime timestamp, float cond1, float cond2, float temp, float hum) {
  Serial.print(timestamp.year(), DEC);
  Serial.print('/');
  Serial.print(timestamp.month(), DEC);
  Serial.print('/');
  Serial.print(timestamp.day(), DEC);
  Serial.print(" ");
  Serial.print(timestamp.hour(), DEC);
  Serial.print(':');
  Serial.print(timestamp.minute(), DEC);
  Serial.print(':');
  Serial.print(timestamp.second(), DEC);
  Serial.print(", Conductivity1: ");
  Serial.print(cond1, 6);
  Serial.print(" S/m, Conductivity2: ");
  Serial.print(cond2, 6);
  Serial.print(" S/m, Temp: ");
  Serial.print(temp, 1);
  Serial.print("C, Humidity: ");
  Serial.print(hum, 1);
  Serial.println("%");
}

void handleWebClient(WiFiClient client) {
  // HTTP request buffer
  String header;
  
  // Current time
  unsigned long currentTime = millis();
  // Previous time
  unsigned long previousTime = 0; 
  // Define timeout time in milliseconds (example: 2000ms = 2s)
  const long timeoutTime = 2000;
  
  // Current time
  currentTime = millis();
  
  // Read the first line of the request
  String currentLine = "";
  while (client.connected() && currentTime - previousTime <= timeoutTime) {
    currentTime = millis();
    if (client.available()) {
      char c = client.read();
      header += c;
      if (c == '\n') {
        // If the current line is blank, you got two newline characters in a row.
        // That's the end of the client HTTP request, so send a response:
        if (currentLine.length() == 0) {
          // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK)
          // and a content-type so the client knows what's coming, then a blank line:
          client.println("HTTP/1.1 200 OK");
          client.println("Content-type:text/html");
          client.println("Connection: close");
          client.println();
          
          // Display the HTML web page
          client.println("<!DOCTYPE html><html>");
          client.println("<head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">");
          client.println("<link rel=\"icon\" href=\"data:,\">");
          // CSS to style the table
          client.println("<style>body { font-family: Arial, Helvetica, Sans-Serif; margin: 0px; }");
          client.println("h1 { background-color: #4CAF50; color: white; padding: 16px; }");
          client.println("table { border-collapse: collapse; width: 80%; margin: 20px auto; }");
          client.println("th, td { text-align: left; padding: 12px; }");
          client.println("tr:nth-child(even) { background-color: #f2f2f2; }");
          client.println("th { background-color: #4CAF50; color: white; }");
          client.println(".container { padding: 16px; }");
          client.println("</style></head>");
          
          // Web Page Heading
          client.println("<body><h1>Mushroom Substrate Conductivity Monitor</h1>");
          
          // Display current data in a table
          client.println("<div class=\"container\">");
          client.println("<table>");
          client.println("<tr><th>Parameter</th><th>Value</th><th>Unit</th></tr>");
          
          client.println("<tr><td>Conductivity (Sensor 1)</td><td>");
          client.println(conductivity1, 6);
          client.println("</td><td>S/m</td></tr>");
          
          client.println("<tr><td>Conductivity (Sensor 2)</td><td>");
          client.println(conductivity2, 6);
          client.println("</td><td>S/m</td></tr>");
          
          client.println("<tr><td>Temperature</td><td>");
          client.println(temperature, 1);
          client.println("</td><td>&deg;C</td></tr>");
          
          client.println("<tr><td>Humidity</td><td>");
          client.println(humidity, 1);
          client.println("</td><td>%</td></tr>");
          
          // Get current time from RTC
          DateTime now = rtc.now();
          
          client.println("<tr><td>Date & Time</td><td>");
          client.print(now.year(), DEC);
          client.print('/');
          client.print(now.month(), DEC);
          client.print('/');
          client.print(now.day(), DEC);
          client.print(" ");
          client.print(now.hour(), DEC);
          client.print(':');
          client.print(now.minute(), DEC);
          client.print(':');
          client.print(now.second(), DEC);
          client.println("</td><td></td></tr>");
          
          client.println("</table>");
          
          // Auto refresh page every 60 seconds
          client.println("<script>setTimeout(function(){location.reload()},60000);</script>");
          
          client.println("</div></body></html>");
          
          // The HTTP response ends with another blank line
          client.println();
          // Break out of the while loop
          break;
        } else { // if you got a newline, then clear currentLine
          currentLine = "";
        }
      } else if (c != '\r') {  // if you got anything else but a carriage return character,
        currentLine += c;      // add it to the end of the currentLine
      }
    }
  }
  // Clear the header variable
  header = "";
  // Close the connection
  client.stop();
}
*/

// ================================================================
// CALIBRATION UTILITY
// ================================================================

/*
// Conductivity Sensor Calibration Utility
// Use this to calibrate your conductivity sensor with standard solutions

// Pin definitions
const int powerPin = 7;      // Digital pin to power one electrode
const int sensePin = A0;     // Analog pin to read voltage

void setup() {
  // Initialize serial communication
  Serial.begin(9600);
  Serial.println("Conductivity Sensor Calibration Utility");
  Serial.println("--------------------------------------");
  Serial.println("1. Place electrodes in standard solution");
  Serial.println("2. Enter the known conductivity value in S/m");
  Serial.println("3. Press Enter to take readings");
  Serial.println("4. The calibration factor will be calculated");
  
  // Set up pins
  pinMode(powerPin, OUTPUT);
  digitalWrite(powerPin, LOW);  // Start with power off
}

void loop() {
  // Check if data is available to read
  if (Serial.available() > 0) {
    // Read the known conductivity value
    float knownConductivity = Serial.parseFloat();
    
    // Clear any remaining characters in the input buffer
    while (Serial.available() > 0) {
      Serial.read();
    }
    
    // Take multiple readings
    int numReadings = 20;
    long total = 0;
    
    Serial.println("Taking readings...");
    
    // Power the electrode
    digitalWrite(powerPin, HIGH);
    delay(500);  // Longer stabilization time for calibration
    
    // Take readings
    for (int i = 0; i < numReadings; i++) {
      total += analogRead(sensePin);
      delay(50);
    }
    
    // Turn off power
    digitalWrite(powerPin, LOW);
    
    // Calculate average
    float averageReading = total / (float)numReadings;
    
    // Convert to voltage
    float voltage = averageReading * (5.0 / 1023.0);
    
    // Calculate calibration factor
    float calibrationFactor = knownConductivity / voltage;
    
    // Display results
    Serial.print("Average analog reading: ");
    Serial.println(averageReading);
    Serial.print("Voltage: ");
    Serial.print(voltage, 4);
    Serial.println(" V");
    Serial.print("Known conductivity: ");
    Serial.print(knownConductivity, 6);
    Serial.println(" S/m");
    Serial.print("Calculated calibration factor: ");
    Serial.println(calibrationFactor, 6);
    Serial.println();
    Serial.println("Update your code with this calibration factor.");
    Serial.println("Ready for next calibration point...");
  }
}
*/

This guide was compiled based on current research and practical experience in the emerging field of conductive mycelium materials. As this is an evolving area of study, experimentation and documentation of your own results will contribute significantly to the knowledge base.

For questions, corrections, or contributions to this guide, please contact the author.

Last updated: [Current Date]
